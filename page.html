<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Microphone Tester</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        background-color: #f8f9fa;
        font-family: Arial, sans-serif;
      }
      canvas {
        width: 100%;
        height: 150px;
        background: #ffffff;
        border: 1px solid #dee2e6;
        margin-bottom: 1rem;
      }
      .controls button {
        margin-right: 10px;
      }
      .timer {
        font-weight: bold;
        font-size: 1.2rem;
      }
    </style>
  </head>
  <body>
    <div class="container py-4">
      <h2 class="mb-4 text-center">ðŸŽ¤ Microphone Test Tool</h2>

      <div class="controls d-flex justify-content-center mb-3">
        <button id="startBtn" class="btn btn-success">Start Recording</button>
        <button id="stopBtn" class="btn btn-danger" disabled>
          Stop Recording
        </button>
        <span class="timer ms-3" id="recordingTimer">00:00</span>
      </div>

      <h5>Waveform</h5>
      <canvas id="waveform"></canvas>

      <h5>Spectrum Analyzer</h5>
      <canvas id="spectrum"></canvas>

      <h5>Stereo Channel Visualizer</h5>
      <canvas id="stereo"></canvas>

      <audio id="audioPlayback" controls class="w-100 mt-3"></audio>
      <a
        id="downloadLink"
        class="btn btn-primary mt-2 d-block"
        download="recording.wav"
        style="display: none"
        >Download Recording</a
      >
    </div>

    <script>
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const timerEl = document.getElementById("recordingTimer");
      const waveformCanvas = document.getElementById("waveform");
      const spectrumCanvas = document.getElementById("spectrum");
      const stereoCanvas = document.getElementById("stereo");
      const audioPlayback = document.getElementById("audioPlayback");
      const downloadLink = document.getElementById("downloadLink");

      let audioContext,
        analyser,
        micStream,
        recorder,
        audioChunks = [];
      let recordingTimer,
        seconds = 0;
      let animationId;

      function updateTimer() {
        seconds++;
        let min = String(Math.floor(seconds / 60)).padStart(2, "0");
        let sec = String(seconds % 60).padStart(2, "0");
        timerEl.textContent = `${min}:${sec}`;
      }

      async function startRecording() {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        micStream = stream;

        audioChunks = [];
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);

        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        source.connect(analyser);

        const stereoSplitter = audioContext.createChannelSplitter(2);

        source.connect(stereoSplitter);

        drawWaveform();
        drawSpectrum();
        drawStereo(stereoSplitter);

        recorder = new MediaRecorder(stream);
        recorder.ondataavailable = (e) => audioChunks.push(e.data);
        recorder.onstop = () => {
          const blob = new Blob(audioChunks, { type: "audio/wav" });
          const url = URL.createObjectURL(blob);
          audioPlayback.src = url;
          downloadLink.href = url;
          downloadLink.style.display = "block";
        };
        recorder.start();

        seconds = 0;
        timerEl.textContent = "00:00";
        recordingTimer = setInterval(updateTimer, 1000);

        startBtn.disabled = true;
        stopBtn.disabled = false;
      }

      function stopRecording() {
        recorder.stop();
        micStream.getTracks().forEach((track) => track.stop());
        clearInterval(recordingTimer);
        cancelAnimationFrame(animationId);

        startBtn.disabled = false;
        stopBtn.disabled = true;
      }

      function drawWaveform() {
        const ctx = waveformCanvas.getContext("2d");
        const bufferLength = analyser.fftSize;
        const dataArray = new Uint8Array(bufferLength);

        function draw() {
          animationId = requestAnimationFrame(draw);
          analyser.getByteTimeDomainData(dataArray);
          ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "#007bff";

          const sliceWidth = waveformCanvas.width / bufferLength;
          let x = 0;

          for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = (v * waveformCanvas.height) / 2;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            x += sliceWidth;
          }
          ctx.stroke();
        }
        draw();
      }

      function drawSpectrum() {
        const ctx = spectrumCanvas.getContext("2d");
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        function draw() {
          animationId = requestAnimationFrame(draw);
          analyser.getByteFrequencyData(dataArray);
          ctx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

          const barWidth = (spectrumCanvas.width / bufferLength) * 2.5;
          let x = 0;
          for (let i = 0; i < bufferLength; i++) {
            const barHeight = dataArray[i];
            ctx.fillStyle = `rgb(${barHeight + 100},50,150)`;
            ctx.fillRect(
              x,
              spectrumCanvas.height - barHeight / 2,
              barWidth,
              barHeight / 2
            );
            x += barWidth + 1;
          }
        }
        draw();
      }

      function drawStereo(splitter) {
        const ctx = stereoCanvas.getContext("2d");
        const analyserL = audioContext.createAnalyser();
        const analyserR = audioContext.createAnalyser();
        analyserL.fftSize = analyserR.fftSize = 256;

        splitter.connect(analyserL, 0);
        splitter.connect(analyserR, 1);

        const bufferLength = analyserL.frequencyBinCount;
        const dataL = new Uint8Array(bufferLength);
        const dataR = new Uint8Array(bufferLength);

        function draw() {
          animationId = requestAnimationFrame(draw);
          analyserL.getByteFrequencyData(dataL);
          analyserR.getByteFrequencyData(dataR);

          ctx.clearRect(0, 0, stereoCanvas.width, stereoCanvas.height);

          const width = stereoCanvas.width;
          const height = stereoCanvas.height / 2;
          const barWidth = width / bufferLength;

          // Left Channel
          for (let i = 0; i < bufferLength; i++) {
            const val = dataL[i];
            ctx.fillStyle = "#28a745";
            ctx.fillRect(i * barWidth, height - val / 2, barWidth, val / 2);
          }

          // Right Channel
          for (let i = 0; i < bufferLength; i++) {
            const val = dataR[i];
            ctx.fillStyle = "#dc3545";
            ctx.fillRect(i * barWidth, height + 2, barWidth, val / 2);
          }
        }
        draw();
      }

      startBtn.addEventListener("click", startRecording);
      stopBtn.addEventListener("click", stopRecording);
    </script>
  </body>
</html>
